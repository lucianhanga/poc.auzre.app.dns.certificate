#!/bin/bash

# Function to show a spinner
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinner='|/-\'
    while [ -d /proc/$pid ]; do
        for i in $(seq 0 3); do
            printf "\r${spinner:$i:1} Deleting resource group..."
            sleep $delay
        done
    done
    printf "\r"
}


# Function to upload certificates with a spinner
upload_certificate() {
    local cert_name=$1
    local cert_file=$2
    # get the secret from the file in a base64 encoded format
    local secret=$(base64 -w 0 $cert_file)
    az keyvault secret set \
        --vault-name $KEYVAULT_NAME \
        --name "$cert_name" \
        --value "$secret" \
        --output none &  # Run in background
    pid=$!  # Get the process ID
    show_spinner $pid  # Show spinner until process finishes
    wait $pid  # Wait for the process to complete

    if [ $? -eq 0 ]; then
        echo -e "\e[32m\xE2\x9C\x94 Successfully uploaded $cert_name\e[0m"
    else
        echo -e "\e[31m\xE2\x9C\x98 Failed to upload $cert_name\e[0m"
        exit 1
    fi
}

# check if you are logged in to GitHub using gh command
# if not logged in, then prompt the user to login
gh auth status > /dev/null
if [ $? -eq 1 ]; then
    # with red color strting with the x mark and the message not logged in to github
    echo -e "\e[31m\xE2\x9C\x98 Not logged in to GitHub\e[0m"
    exit 1
else
    # with green color -  check mark and the message logged in to github
    echo -e "\e[32m\xE2\x9C\x94 Logged in to GitHub\e[0m"
fi

# make sure that you are loogged in to azure with credentials 
# which have access to create resource groups, and service principals
# and give the required permissions to the service principal

# step1 check if the user is logged in
az account show > /dev/null
# if errr code is 1 then user is not logged in
if [ $? -eq 1 ]; then
    # with red color strting with the x mark and the message not logged in to azure
    echo -e "\e[31m\xE2\x9C\x98 Not logged in to azure\e[0m"
    exit 1
else
    # with green color -  check mark and the message logged in to azure
    echo -e "\e[32m\xE2\x9C\x94 Logged in to azure\e[0m"
fi




# get all the resources from the ../terraform/terraform.tfstate file
if [ -f ../terraform/terraform.tfvars ]; then
  # with green color checked mark and the message
  echo -e "\e[32m\xE2\x9C\x94 Terraform variables file found\e[0m"
  # source the file
  source ../terraform/terraform.tfvars
else
  # with red color x mark and the message
  echo -e "\e[31m\xE2\x9C\x98 Terraform variables file not found\e[0m"
  # finish the script
  echo "Exiting..."
  exit 0
fi

# print the values of the variables with green color
echo -e "client_id=\033[0;32m$client_id\033[0m"
echo -e "client_secret=\033[0;32m$client_secret\033[0m"
echo -e "tenant_id=\033[0;32m$tenant_id\033[0m"
echo -e "subscription_id=\033[0;32m$subscription_id\033[0m"
echo -e "object_id=\033[0;32m$object_id\033[0m"
echo -e "location=\033[0;32m$location\033[0m"
echo -e "resource_group_name=\033[0;32m$resource_group_name\033[0m"
echo -e "project_name=\033[0;32m$project_name\033[0m"
echo -e "project_suffix=\033[0;32m$project_suffix\033[0m"

# create the keyvault name by appending the "kv-" to the project name and suffix
KEYVAULT_NAME="kv-$project_name$project_suffix"
echo -e "KEYVAULT_NAME=\033[0;32m$KEYVAULT_NAME\033[0m"

# check if the current logged in user has "Key Valut Secret Officer" role in the keyvault
KEYVAULT_ID=$(az keyvault show --name $KEYVAULT_NAME --query id --output tsv)
echo -e "KEYVAULT_ID=\033[0;32m$KEYVAULT_ID\033[0m"
# # list the roles for the current user in the keyvault
# # SIGNED_IN_USER=$(az ad signed-in-user show --query userPrincipalName -o tsv)
# SIGN_IN_USER=$(az account show --query user.name -o tsv)
# echo -e "SIGN_IN_USER=\033[0;32m$SIGNED_IN_USER\033[0m"
# # check if the user has the "Key Vault Secrets Officer" role in the keyvault
# az role assignment list --scope $KEYVAULT_ID
# exit 0  
# az role assignment list --scope $KEYVAULT_ID --assignee $SIGNED_IN_USER --role "Key Vault Secrets Officer" > /dev/null
# if [ $? -eq 1 ]; then
#     echo -e "\e[31m\xE2\x9C\x98 User does not have the 'Key Vault Secrets Officer' role\e[0m"
#     # write the reson for exiting is that secrets cannot be added
#     echo "Secrets cannot be added to the keyvault"
#     echo "Exiting..."
#     exit 1
# else
#     echo -e "\e[32m\xE2\x9C\x94 User has the 'Key Vault Secrets Officer' role\e[0m"
# fi

echo "Creating fake certificates for testing"
# Fake tthe generation of the certificates 
# like they wold have been generated by letsencrypt in a workflow action
# uploaded as artifacts
# and downloaded in the current folder
# all 4 files are needed
# cert.pem
# chain.pem
# fullchain.pem
# privkey.pem
echo "---BEGIN FAKE CERTIFICATE---" > cert.pem
echo "---END FAKE CERTIFICATE---" >> cert.pem
echo "---BEGIN FAKE CERTIFICATE---" > chain.pem
echo "---END FAKE CERTIFICATE---" >> chain.pem
echo "---BEGIN FAKE CERTIFICATE---" > fullchain.pem
echo "---END FAKE CERTIFICATE---" >> fullchain.pem
echo "---BEGIN FAKE CERTIFICATE---" > privkey.pem
echo "---END FAKE CERTIFICATE---" >> privkey.pem

# also the openssl generated pfx file
echo "---BEGIN FAKE CERTIFICATE---" > cert.pfx
echo "---END FAKE CERTIFICATE---" >> cert.pfx
echo "done"
 
# list the certificates
# ls -l

# upload the certificates to the keyvault
echo "Uploading the certificates to the keyvault"

upload_certificate "cert-pem" "cert.pem"
upload_certificate "chain-pem" "chain.pem"
upload_certificate "fullchain-pem" "fullchain.pem"
upload_certificate "privkey-pem" "privkey.pem"
upload_certificate "cert-pfx" "cert.pfx"
